{
  "language": "Solidity",
  "sources": {
    "@anon-aadhaar/contracts/interfaces/IAnonAadhaar.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.19;\n\ninterface IAnonAadhaar {\n    function verifyAnonAadhaarProof(\n        uint nullifierSeed,\n        uint nullifier,\n        uint timestamp,\n        uint signal,\n        uint[4] memory revealArray,\n        uint[8] memory groth16Proof\n    ) external view returns (bool);\n}\n"
    },
    "@anon-aadhaar/contracts/interfaces/IAnonAadhaarVote.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.19;\n\ninterface IAnonAadhaarVote {\n\n    struct Proposal {\n        string description;\n        uint256 voteCount;\n    }\n\n    event Voted(address indexed _from, uint256 indexed _propositionIndex);\n}"
    },
    "contracts/Backend.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"@anon-aadhaar/contracts/interfaces/IAnonAadhaar.sol\";\r\nimport \"@anon-aadhaar/contracts/interfaces/IAnonAadhaarVote.sol\";\r\nimport \"../interfaces/IAnonDigiLockerGroth16Verifier.sol\";\r\nimport \"../interfaces/IAnonDigiLocker.sol\";\r\n\r\ncontract Backend {\r\n    address public anonAadhaarVerifierAddr;\r\n    address public verifier;\r\n    uint256 public immutable storedPublicKeyHash;\r\n    address[] public allUsers; // Array to track all user addresses\r\n    struct User {\r\n        string basename;\r\n        string vehicleRegistrationNumber;\r\n        string vehicleType;\r\n        address walletAddress; // keep only this one\r\n        uint256 pendingFines;\r\n        uint256 rewardBalance;\r\n        uint256 points; // Added points field\r\n    }\r\n\r\n    struct Violation {\r\n        uint256 time;\r\n        string violationType;\r\n        string area; // Add area field\r\n        address reportedBy;\r\n        bool isPaid;\r\n        uint256 fineAmount;\r\n    }\r\n\r\n    struct CreateUserParams {\r\n        uint256 nullifierSeed1;\r\n        uint256 nullifier1;\r\n        uint256 timestamp;\r\n        uint256[4] revealArray;\r\n        uint256[8] groth16Proof1;\r\n        // uint256 nullifier2;\r\n        // uint256 nullifierSeed2;\r\n        // uint256 documentType;\r\n        // uint256 reveal;\r\n        // uint256 signal;\r\n        // uint256[8] groth16Proof2;\r\n    }\r\n\r\n    uint256 public totalRewardPool;\r\n    uint256 public totalpoints;\r\n    mapping(address => User) public users;\r\n    mapping(string => address) public vehicleToUser;\r\n    mapping(address => Violation[]) userViolations;\r\n    mapping(address => uint256) public finesPaid;\r\n    mapping(string => uint256) public violationFines;\r\n\r\n    event UserCreated(address indexed userAddress, string name, string vehicleRegistrationNumber);\r\n    event RewardUpdated(address indexed user, uint256 newRewardBalance);\r\n    event ViolationReported(address indexed user, string violationType, address reportedBy, uint256 fineAmount);\r\n    event FinePaid(address indexed user, uint256 violationIndex, uint256 amount);\r\n\r\n    constructor(address _verifierAddr, address _verifier, uint256 _pubkeyHash) {\r\n        verifier = _verifier;\r\n        // Initialize some dummy fine amounts for violation types\r\n        anonAadhaarVerifierAddr = _verifierAddr;\r\n        storedPublicKeyHash = _pubkeyHash;\r\n        violationFines[\"Speeding\"] = 80;\r\n        violationFines[\"Parking\"] = 40;\r\n        violationFines[\"Red Light\"] = 60;\r\n        violationFines[\"Wrong way\"] = 90;\r\n        totalRewardPool = 1000; // Initialize with 1000\r\n        totalpoints = 0;\r\n    }\r\n\r\n    // ---------------------- REWARDS SYSTEM FUNCTIONS ----------------------\r\n\r\n    // Function to add to the total reward pool\r\n    function addUserReward(address _user, uint256 _newReward) public {\r\n        require(users[_user].walletAddress != address(0), \"User does not exist\");\r\n\r\n        users[_user].rewardBalance += _newReward;\r\n        emit RewardUpdated(_user, _newReward);\r\n    }\r\n\r\n    // Function to fetch a user's reward balance\r\n    function getMyRewards() public view returns (uint256) {\r\n        User storage user = users[msg.sender];\r\n        return user.rewardBalance;\r\n    }\r\n\r\n    function addressToUint256(address _addr) private pure returns (uint256) {\r\n        return uint256(uint160(_addr));\r\n    }\r\n\r\n    function _hash(uint256 message) private pure returns (uint256) {\r\n        return uint256(keccak256(abi.encodePacked(message))) >> 3;\r\n    }\r\n\r\n    function verifyAnonAadhaar(\r\n        uint256 nullifierSeed,\r\n        uint256 nullifier,\r\n        uint256 timestamp,\r\n        uint256[4] memory revealArray,\r\n        uint256[8] memory groth16Proof\r\n    ) internal returns (bool) {\r\n        return\r\n            IAnonAadhaar(anonAadhaarVerifierAddr).verifyAnonAadhaarProof(\r\n                nullifierSeed,\r\n                nullifier,\r\n                timestamp,\r\n                addressToUint256(msg.sender),\r\n                revealArray,\r\n                groth16Proof\r\n            );\r\n    }\r\n\r\n    function verifyDigiLocker(\r\n        uint256[8] memory proof,\r\n        uint256 nullifier,\r\n        uint256 documentType,\r\n        uint256 reveal,\r\n        uint256 nullifierSeed,\r\n        uint256 signal\r\n    ) internal view returns (bool) {\r\n        uint256 signalHash = _hash(signal);\r\n        return\r\n            IAnonDigiLockerGroth16Verifier(verifier).verifyProof(\r\n                [proof[0], proof[1]],\r\n                [[proof[2], proof[3]], [proof[4], proof[5]]],\r\n                [proof[6], proof[7]],\r\n                [storedPublicKeyHash, nullifier, documentType, reveal, nullifierSeed, signalHash]\r\n            );\r\n    }\r\n\r\n    // Create a new user\r\n    function createUser(\r\n        string memory _basename,\r\n        string memory _vehicleRegistrationNumber,\r\n        string memory _vehicleType,\r\n        CreateUserParams memory params // removed _userAddress parameter\r\n    ) public payable {\r\n        require(users[msg.sender].walletAddress == address(0), \"User already exists\");\r\n\r\n        bool isValid = verifyAnonAadhaar(\r\n            params.nullifierSeed1,\r\n            params.nullifier1,\r\n            params.timestamp,\r\n            params.revealArray,\r\n            params.groth16Proof1\r\n        );\r\n        require(isValid, \"[AnonAadhaarVote]: proof sent is not valid.\");\r\n\r\n        // bool isValid2 = verifyDigiLocker(\r\n        //     params.groth16Proof2,\r\n        //     params.nullifier2,\r\n        //     params.documentType,\r\n        //     params.reveal,\r\n        //     params.nullifierSeed2,\r\n        //     params.signal\r\n        // );\r\n        // require(isValid || isValid2, 'Proof sent is not valid.');\r\n        // require(isValid2, '[AnonAadhaarVote]: DL Proof sent is not valid.');\r\n\r\n        users[msg.sender] = User({\r\n            basename: _basename,\r\n            vehicleRegistrationNumber: _vehicleRegistrationNumber,\r\n            vehicleType: _vehicleType,\r\n            walletAddress: msg.sender,\r\n            pendingFines: 0,\r\n            rewardBalance: 0,\r\n            points: 100 // Start with 100 points\r\n        });\r\n        allUsers.push(msg.sender); // Add this line after creating new user\r\n        vehicleToUser[_vehicleRegistrationNumber] = msg.sender;\r\n        totalpoints += 100;\r\n        emit UserCreated(msg.sender, _basename, _vehicleRegistrationNumber);\r\n    }\r\n\r\n    // Report a violation\r\n    function reportViolation(\r\n        address _user,\r\n        string memory _violationType,\r\n        uint256 _timestamp,\r\n        string memory _area\r\n    ) public {\r\n        require(users[_user].walletAddress != address(0), \"User does not exist\");\r\n        require(violationFines[_violationType] > 0, \"Invalid violation type\");\r\n        require(_timestamp <= block.timestamp, \"Invalid timestamp\");\r\n\r\n        uint256 fineAmount = violationFines[_violationType];\r\n        userViolations[_user].push(\r\n            Violation({\r\n                time: _timestamp,\r\n                violationType: _violationType,\r\n                area: _area,\r\n                reportedBy: msg.sender,\r\n                isPaid: false,\r\n                fineAmount: fineAmount\r\n            })\r\n        );\r\n        users[_user].pendingFines++;\r\n        emit ViolationReported(_user, _violationType, msg.sender, fineAmount);\r\n    }\r\n\r\n    // Fetch all violations of a user\r\n    function getUserViolations(address _user) public view returns (Violation[] memory) {\r\n        return userViolations[_user];\r\n    }\r\n\r\n    // Pay a fine\r\n    function payFine(\r\n        address _user,\r\n        uint256 _violationIndex,\r\n        uint256 nullifierSeed,\r\n        uint256 nullifier,\r\n        uint256 timestamp,\r\n        uint256[4] memory revealArray,\r\n        uint256[8] memory groth16Proof\r\n    ) public payable {\r\n        require(users[_user].walletAddress != address(0), \"User does not exist\");\r\n        require(!userViolations[_user][_violationIndex].isPaid, \"Fine already paid\");\r\n        bool isValid = IAnonAadhaar(anonAadhaarVerifierAddr).verifyAnonAadhaarProof(\r\n            nullifierSeed,\r\n            nullifier,\r\n            timestamp,\r\n            addressToUint256(msg.sender),\r\n            revealArray,\r\n            groth16Proof\r\n        );\r\n        require(isValid, \"[AnonAadhaarVote]: proof sent is not valid.\");\r\n\r\n        Violation storage violation = userViolations[_user][_violationIndex];\r\n        require(msg.value == violation.fineAmount, \"Payment must be equal to the fine amount\");\r\n\r\n        violation.isPaid = true;\r\n        users[_user].pendingFines--;\r\n        finesPaid[_user] += msg.value;\r\n        totalRewardPool += msg.value; // Add fine amount to total reward pool\r\n        emit FinePaid(_user, _violationIndex, msg.value);\r\n    }\r\n\r\n    function addPoints(string memory _basename, uint256 _points) public {\r\n        address userAddress;\r\n        for (uint i = 0; i < allUsers.length; i++) {\r\n            if (keccak256(bytes(users[allUsers[i]].basename)) == keccak256(bytes(_basename))) {\r\n                userAddress = allUsers[i];\r\n                break;\r\n            }\r\n        }\r\n        require(userAddress != address(0), \"User not found\");\r\n        \r\n        users[userAddress].points += _points;\r\n        totalpoints += _points;\r\n    }\r\n\r\n    function convertPointsToRewards() public {\r\n        User storage user = users[msg.sender];\r\n        require(user.points > 0, \"No points to convert\");\r\n        require(totalRewardPool > 0, \"Reward pool is empty\");\r\n        require(totalpoints > 0, \"No points in the system\");\r\n\r\n        // Calculate user's share of the reward pool\r\n        uint256 rewardShare = (user.points * totalRewardPool) / totalpoints;\r\n\r\n        // Ensure contract has enough Ether\r\n        require(address(this).balance >= rewardShare, \"Not enough funds in contract to pay rewards\");\r\n\r\n        // Transfer reward to the user's wallet\r\n        (bool success, ) = msg.sender.call{ value: rewardShare }(\"\");\r\n        require(success, \"Reward transfer failed\");\r\n\r\n        // Update user's internal balances\r\n        user.rewardBalance += rewardShare; // For internal tracking\r\n        totalpoints-=user.points;\r\n        user.points = 0; // Reset points after conversion\r\n        totalRewardPool -= rewardShare;\r\n\r\n        emit RewardUpdated(msg.sender, user.rewardBalance);\r\n    }\r\n\r\n    function getContractBalance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function getUserDetailsByAddress(\r\n        address _walletAddress\r\n    ) public view returns (\r\n        string memory basename,\r\n        string memory vehicleNumber,\r\n        string memory vehicleType,\r\n        uint256 pendingFines,\r\n        uint256 rewardBalance,\r\n        uint256 points\r\n    ) {\r\n        require(users[_walletAddress].walletAddress != address(0), \"User does not exist\");\r\n        User memory user = users[_walletAddress];\r\n        return (\r\n            user.basename,\r\n            user.vehicleRegistrationNumber,\r\n            user.vehicleType,\r\n            user.pendingFines,\r\n            user.rewardBalance,\r\n            user.points\r\n        );\r\n    }\r\n\r\n    function getUserDetailsByBasename(\r\n        string memory _basename\r\n    ) public view returns (\r\n        string memory basename,\r\n        string memory vehicleNumber,\r\n        string memory vehicleType,\r\n        address walletAddress,\r\n        uint256 pendingFines,\r\n        uint256 rewardBalance,\r\n        uint256 points\r\n    ) {\r\n        address userAddress;\r\n        for (uint i = 0; i < allUsers.length; i++) {\r\n            if (keccak256(bytes(users[allUsers[i]].basename)) == keccak256(bytes(_basename))) {\r\n                userAddress = allUsers[i];\r\n                break;\r\n            }\r\n        }\r\n        require(userAddress != address(0), \"User not found\");\r\n        \r\n        User memory user = users[userAddress];\r\n        return (\r\n            user.basename,\r\n            user.vehicleRegistrationNumber,\r\n            user.vehicleType,\r\n            user.walletAddress,\r\n            user.pendingFines,\r\n            user.rewardBalance,\r\n            user.points\r\n        );\r\n    }\r\n\r\n    function getAllUsersAndPoints()\r\n        public\r\n        view\r\n        returns (\r\n            string[] memory basenames, // changed from usernames to basenames\r\n            uint256[] memory points\r\n        )\r\n    {\r\n        uint256 totalUsers = allUsers.length;\r\n        basenames = new string[](totalUsers); // changed variable name\r\n        points = new uint256[](totalUsers);\r\n\r\n        for (uint256 i = 0; i < totalUsers; i++) {\r\n            address userAddress = allUsers[i];\r\n            basenames[i] = users[userAddress].basename; // changed variable name\r\n            points[i] = users[userAddress].points;\r\n        }\r\n\r\n        return (basenames, points); // changed return variable name\r\n    }\r\n\r\n    function getUserPoints(address _userAddress) public view returns (uint256) {\r\n        require(users[_userAddress].walletAddress != address(0), \"User does not exist\");\r\n        return users[_userAddress].points;\r\n    }\r\n\r\n    struct UserViolationInfo {\r\n        address userAddress;\r\n        string basename;\r\n        Violation[] violations;\r\n    }\r\n\r\n    function getAllUsersAndViolations() public view returns (UserViolationInfo[] memory) {\r\n        uint256 totalUsers = allUsers.length;\r\n        UserViolationInfo[] memory allUserInfo = new UserViolationInfo[](totalUsers);\r\n\r\n        for (uint256 i = 0; i < totalUsers; i++) {\r\n            address userAddr = allUsers[i];\r\n            allUserInfo[i] = UserViolationInfo({\r\n                userAddress: userAddr,\r\n                basename: users[userAddr].basename,\r\n                violations: userViolations[userAddr]\r\n            });\r\n        }\r\n\r\n        return allUserInfo;\r\n    }\r\n\r\n    // Add this new function for daily points update\r\n    function addDailyPoints() public {\r\n        uint256 totalUsers = allUsers.length;\r\n        for (uint256 i = 0; i < totalUsers; i++) {\r\n            address userAddr = allUsers[i];\r\n            if (users[userAddr].pendingFines == 0) {\r\n                users[userAddr].points += 10;\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "interfaces/IAnonDigiLocker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.19;\r\n\r\ninterface IAnonDigiLocker {\r\n    function verifyAnonDigiLockerProof(\r\n        uint nullifierSeed,\r\n        uint nullifier,\r\n        uint documentType,\r\n        uint reveal,\r\n        uint signal,\r\n        uint[8] memory groth16Proof\r\n    ) external view returns (bool);\r\n}"
    },
    "interfaces/IAnonDigiLockerGroth16Verifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.19;\r\n\r\ninterface IAnonDigiLockerGroth16Verifier {\r\n    function verifyProof(\r\n        uint[2] calldata _pA,\r\n        uint[2][2] calldata _pB,\r\n        uint[2] calldata _pC,\r\n        uint[6] calldata publicInputs\r\n    ) external view returns (bool);\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}