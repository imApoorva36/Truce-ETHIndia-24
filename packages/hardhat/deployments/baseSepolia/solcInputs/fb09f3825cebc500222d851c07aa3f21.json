{
  "language": "Solidity",
  "sources": {
    "@anon-aadhaar/contracts/interfaces/IAnonAadhaar.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.19;\n\ninterface IAnonAadhaar {\n    function verifyAnonAadhaarProof(\n        uint nullifierSeed,\n        uint nullifier,\n        uint timestamp,\n        uint signal,\n        uint[4] memory revealArray,\n        uint[8] memory groth16Proof\n    ) external view returns (bool);\n}\n"
    },
    "@anon-aadhaar/contracts/interfaces/IAnonAadhaarVote.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.19;\n\ninterface IAnonAadhaarVote {\n\n    struct Proposal {\n        string description;\n        uint256 voteCount;\n    }\n\n    event Voted(address indexed _from, uint256 indexed _propositionIndex);\n}"
    },
    "contracts/YourContract.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\r\n\r\ncontract YourContract {\r\n    struct User {\r\n        string name;\r\n        string vehicleRegistrationNumber;\r\n        address walletAddress;\r\n        uint256 pendingFines;\r\n    }\r\n\r\n    struct Violation {\r\n        uint256 time;\r\n        string violationType;\r\n        address reportedBy;\r\n        bool isPaid;\r\n        uint256 fineAmount;\r\n    }\r\n\r\n    mapping(address => User) public users;\r\n    mapping(string => address) public vehicleToUser;\r\n    mapping(address => Violation[]) userViolations;\r\n    mapping(address => uint256) public finesPaid;\r\n    mapping(string => uint256) public violationFines;\r\n\r\n    event UserCreated(address indexed userAddress, string name, string vehicleRegistrationNumber);\r\n    event ViolationReported(address indexed user, string violationType, address reportedBy, uint256 fineAmount);\r\n    event FinePaid(address indexed user, uint256 violationIndex, uint256 amount);\r\n\r\n    constructor() {\r\n        // Initialize some dummy fine amounts for violation types\r\n        violationFines[\"Speeding\"] = 100;\r\n        violationFines[\"Parking\"] = 50;\r\n        violationFines[\"Red Light\"] = 200;\r\n    }\r\n\r\n    // Create a new user\r\n    function createUser(string memory _name, string memory _vehicleRegistrationNumber) public {\r\n        require(users[msg.sender].walletAddress == address(0), \"User already exists\");\r\n        users[msg.sender] = User({\r\n            name: _name,\r\n            vehicleRegistrationNumber: _vehicleRegistrationNumber,\r\n            walletAddress: msg.sender,\r\n            pendingFines: 0\r\n        });\r\n        vehicleToUser[_vehicleRegistrationNumber] = msg.sender;\r\n        emit UserCreated(msg.sender, _name, _vehicleRegistrationNumber);\r\n    }\r\n\r\n    // Report a violation\r\n    function reportViolation(address _user, string memory _violationType) public {\r\n        require(users[_user].walletAddress != address(0), \"User does not exist\");\r\n        require(violationFines[_violationType] > 0, \"Invalid violation type\");\r\n\r\n        uint256 fineAmount = violationFines[_violationType];\r\n        userViolations[_user].push(Violation({\r\n            time: block.timestamp,\r\n            violationType: _violationType,\r\n            reportedBy: msg.sender,\r\n            isPaid: false,\r\n            fineAmount: fineAmount\r\n        }));\r\n        users[_user].pendingFines++;\r\n        emit ViolationReported(_user, _violationType, msg.sender, fineAmount);\r\n    }\r\n\r\n    // Fetch all violations of a user\r\n    function getUserViolations(address _user) public view returns (Violation[] memory) {\r\n        return userViolations[_user];\r\n    }\r\n\r\n    // Pay a fine\r\n    function payFine(address _user, uint256 _violationIndex) public payable {\r\n        require(users[_user].walletAddress != address(0), \"User does not exist\");\r\n        require(_violationIndex < userViolations[_user].length, \"Invalid violation index\");\r\n        require(!userViolations[_user][_violationIndex].isPaid, \"Fine already paid\");\r\n\r\n        Violation storage violation = userViolations[_user][_violationIndex];\r\n        require(msg.value == violation.fineAmount, \"Payment must be equal to the fine amount\");\r\n\r\n        violation.isPaid = true;\r\n        users[_user].pendingFines--;\r\n        finesPaid[_user] += msg.value;\r\n        emit FinePaid(_user, _violationIndex, msg.value);\r\n    }\r\n}\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.19;\r\n\r\nimport '@anon-aadhaar/contracts/interfaces/IAnonAadhaar.sol';\r\nimport '@anon-aadhaar/contracts/interfaces/IAnonAadhaarVote.sol';\r\n\r\ncontract AnonAadhaarVote is IAnonAadhaarVote {\r\n    string public votingQuestion;\r\n    address public anonAadhaarVerifierAddr;\r\n\r\n    // List of proposals\r\n    Proposal[] public proposals;\r\n\r\n    // Mapping to track if a userNullifier has already voted\r\n    mapping(uint256 => bool) public hasVoted;\r\n\r\n    // Constructor to initialize proposals\r\n    constructor(\r\n        string memory _votingQuestion,\r\n        string[] memory proposalDescriptions,\r\n        address _verifierAddr\r\n    ) {\r\n        anonAadhaarVerifierAddr = _verifierAddr;\r\n        votingQuestion = _votingQuestion;\r\n        for (uint256 i = 0; i < proposalDescriptions.length; i++) {\r\n            proposals.push(Proposal(proposalDescriptions[i], 0));\r\n        }\r\n    }\r\n\r\n    /// @dev Convert an address to uint256, used to check against signal.\r\n    /// @param _addr: msg.sender address.\r\n    /// @return Address msg.sender's address in uint256\r\n    function addressToUint256(address _addr) private pure returns (uint256) {\r\n        return uint256(uint160(_addr));\r\n    }\r\n\r\n    /// @dev Check if the timestamp is more recent than (current time - 3 hours)\r\n    /// @param timestamp: msg.sender address.\r\n    /// @return bool\r\n    function isLessThan3HoursAgo(uint timestamp) public view returns (bool) {\r\n        return timestamp > (block.timestamp - 3 * 60 * 60);\r\n    }\r\n\r\n    /// @dev Register a vote in the contract.\r\n    /// @param proposalIndex: Index of the proposal you want to vote for.\r\n    /// @param nullifierSeed: Nullifier Seed used while generating the proof.\r\n    /// @param nullifier: Nullifier for the user's Aadhaar data.\r\n    /// @param timestamp: Timestamp of when the QR code was signed.\r\n    /// @param signal: signal used while generating the proof, should be equal to msg.sender.\r\n    /// @param revealArray: Array of the values used as input for the proof generation (equal to [0, 0, 0, 0] if no field reveal were asked).\r\n    /// @param groth16Proof: SNARK Groth16 proof.\r\n    function voteForProposal(\r\n        uint256 proposalIndex,\r\n        uint nullifierSeed,\r\n        uint nullifier,\r\n        uint timestamp,\r\n        uint signal,\r\n        uint[4] memory revealArray, \r\n        uint[8] memory groth16Proof\r\n    ) public {\r\n        require(\r\n            proposalIndex < proposals.length,\r\n            '[AnonAadhaarVote]: Invalid proposal index'\r\n        );\r\n        require(\r\n            isLessThan3HoursAgo(timestamp) == true,\r\n            '[AnonAadhaarVote]: Proof must be generated with Aadhaar data generated less than 3 hours ago.'\r\n        );\r\n        require(\r\n            IAnonAadhaar(anonAadhaarVerifierAddr).verifyAnonAadhaarProof(\r\n                nullifierSeed, // nulifier seed\r\n                nullifier,\r\n                timestamp,\r\n                signal,\r\n                revealArray,\r\n                groth16Proof\r\n            ) == true,\r\n            '[AnonAadhaarVote]: proof sent is not valid.'\r\n        );\r\n        // Check that user hasn't already voted\r\n        require(\r\n            !hasVoted[nullifier],\r\n            '[AnonAadhaarVote]: User has already voted'\r\n        );\r\n\r\n        proposals[proposalIndex].voteCount++;\r\n        hasVoted[nullifier] = true;\r\n\r\n        emit Voted(msg.sender, proposalIndex);\r\n    }\r\n\r\n    // Function to get the total number of proposals\r\n    function getProposalCount() public view returns (uint256) {\r\n        return proposals.length;\r\n    }\r\n\r\n    // Function to get proposal information by index\r\n    function getProposal(\r\n        uint256 proposalIndex\r\n    ) public view returns (string memory, uint256) {\r\n        require(\r\n            proposalIndex < proposals.length,\r\n            '[AnonAadhaarVote]: Invalid proposal index'\r\n        );\r\n\r\n        Proposal memory proposal = proposals[proposalIndex];\r\n        return (proposal.description, proposal.voteCount);\r\n    }\r\n\r\n    // Function to get the total number of votes across all proposals\r\n    function getTotalVotes() public view returns (uint256) {\r\n        uint256 totalVotes = 0;\r\n        for (uint256 i = 0; i < proposals.length; i++) {\r\n            totalVotes += proposals[i].voteCount;\r\n        }\r\n        return totalVotes;\r\n    }\r\n\r\n    // Function to check if a user has already voted\r\n    function checkVoted(uint256 _nullifier) public view returns (bool) {\r\n        return hasVoted[_nullifier];\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}