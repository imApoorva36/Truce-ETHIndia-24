{
  "language": "Solidity",
  "sources": {
    "@anon-aadhaar/contracts/interfaces/IAnonAadhaar.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.19;\n\ninterface IAnonAadhaar {\n    function verifyAnonAadhaarProof(\n        uint nullifierSeed,\n        uint nullifier,\n        uint timestamp,\n        uint signal,\n        uint[4] memory revealArray,\n        uint[8] memory groth16Proof\n    ) external view returns (bool);\n}\n"
    },
    "@anon-aadhaar/contracts/interfaces/IAnonAadhaarVote.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.19;\n\ninterface IAnonAadhaarVote {\n\n    struct Proposal {\n        string description;\n        uint256 voteCount;\n    }\n\n    event Voted(address indexed _from, uint256 indexed _propositionIndex);\n}"
    },
    "contracts/Backend.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n\nimport \"@anon-aadhaar/contracts/interfaces/IAnonAadhaar.sol\";\nimport \"@anon-aadhaar/contracts/interfaces/IAnonAadhaarVote.sol\";\nimport \"../interfaces/IAnonDigiLockerGroth16Verifier.sol\";\nimport \"../interfaces/IAnonDigiLocker.sol\";\n\ncontract Backend {\n    address public anonAadhaarVerifierAddr;\n    address public verifier;\n    uint256 public immutable storedPublicKeyHash;\n    address[] public allUsers; // Array to track all user addresses\n    struct User {\n        string basename;\n        string vehicleRegistrationNumber;\n        string vehicleType;\n        address walletAddress; // keep only this one\n        uint256 pendingFines;\n        uint256 rewardBalance;\n        uint256 points; // Added points field\n    }\n\n    struct Violation {\n        uint256 time;\n        string violationType;\n        string area; // Add area field\n        address reportedBy;\n        bool isPaid;\n        uint256 fineAmount;\n    }\n\n    struct CreateUserParams {\n        uint256 nullifierSeed1;\n        uint256 nullifier1;\n        uint256 timestamp;\n        uint256[4] revealArray;\n        uint256[8] groth16Proof1;\n        // uint256 nullifier2;\n        // uint256 nullifierSeed2;\n        // uint256 documentType;\n        // uint256 reveal;\n        // uint256 signal;\n        // uint256[8] groth16Proof2;\n    }\n\n    uint256 public totalRewardPool;\n    uint256 public totalpoints;\n    mapping(address => User) public users;\n    mapping(string => address) public vehicleToUser;\n    mapping(address => Violation[]) userViolations;\n    mapping(address => uint256) public finesPaid;\n    mapping(string => uint256) public violationFines;\n\n    event UserCreated(address indexed userAddress, string name, string vehicleRegistrationNumber);\n    event RewardUpdated(address indexed user, uint256 newRewardBalance);\n    event ViolationReported(address indexed user, string violationType, address reportedBy, uint256 fineAmount);\n    event FinePaid(address indexed user, uint256 violationIndex, uint256 amount);\n\n    constructor(address _verifierAddr, address _verifier, uint256 _pubkeyHash) {\n        verifier = _verifier;\n        // Initialize some dummy fine amounts for violation types\n        anonAadhaarVerifierAddr = _verifierAddr;\n        storedPublicKeyHash = _pubkeyHash;\n        violationFines[\"Speeding\"] = 80;\n        violationFines[\"Parking\"] = 40;\n        violationFines[\"Red Light\"] = 60;\n        violationFines[\"Wrong way\"] = 90;\n        totalRewardPool = 0; // Initialize with 1000\n        totalpoints = 0;\n    }\n\n    // ---------------------- REWARDS SYSTEM FUNCTIONS ----------------------\n\n    // Function to add to the total reward pool\n    function addUserReward(address _user, uint256 _newReward) public {\n        require(users[_user].walletAddress != address(0), \"User does not exist\");\n\n        users[_user].rewardBalance += _newReward;\n        emit RewardUpdated(_user, _newReward);\n    }\n\n    // Function to fetch a user's reward balance\n    function getMyRewards() public view returns (uint256) {\n        User storage user = users[msg.sender];\n        return user.rewardBalance;\n    }\n\n    function addressToUint256(address _addr) private pure returns (uint256) {\n        return uint256(uint160(_addr));\n    }\n\n    function _hash(uint256 message) private pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(message))) >> 3;\n    }\n\n    function verifyAnonAadhaar(\n        uint256 nullifierSeed,\n        uint256 nullifier,\n        uint256 timestamp,\n        uint256[4] memory revealArray,\n        uint256[8] memory groth16Proof\n    ) internal returns (bool) {\n        return\n            IAnonAadhaar(anonAadhaarVerifierAddr).verifyAnonAadhaarProof(\n                nullifierSeed,\n                nullifier,\n                timestamp,\n                addressToUint256(msg.sender),\n                revealArray,\n                groth16Proof\n            );\n    }\n\n    function verifyDigiLocker(\n        uint256[8] memory proof,\n        uint256 nullifier,\n        uint256 documentType,\n        uint256 reveal,\n        uint256 nullifierSeed,\n        uint256 signal\n    ) internal view returns (bool) {\n        uint256 signalHash = _hash(signal);\n        return\n            IAnonDigiLockerGroth16Verifier(verifier).verifyProof(\n                [proof[0], proof[1]],\n                [[proof[2], proof[3]], [proof[4], proof[5]]],\n                [proof[6], proof[7]],\n                [storedPublicKeyHash, nullifier, documentType, reveal, nullifierSeed, signalHash]\n            );\n    }\n\n    // Create a new user\n    function createUser(\n        string memory _basename,\n        string memory _vehicleRegistrationNumber,\n        string memory _vehicleType,\n        CreateUserParams memory params // removed _userAddress parameter\n    ) public payable {\n        require(users[msg.sender].walletAddress == address(0), \"User already exists\");\n\n        bool isValid = verifyAnonAadhaar(\n            params.nullifierSeed1,\n            params.nullifier1,\n            params.timestamp,\n            params.revealArray,\n            params.groth16Proof1\n        );\n        require(isValid, \"[AnonAadhaarVote]: proof sent is not valid.\");\n\n        // bool isValid2 = verifyDigiLocker(\n        //     params.groth16Proof2,\n        //     params.nullifier2,\n        //     params.documentType,\n        //     params.reveal,\n        //     params.nullifierSeed2,\n        //     params.signal\n        // );\n        // require(isValid || isValid2, 'Proof sent is not valid.');\n        // require(isValid2, '[AnonAadhaarVote]: DL Proof sent is not valid.');\n\n        users[msg.sender] = User({\n            basename: _basename,\n            vehicleRegistrationNumber: _vehicleRegistrationNumber,\n            vehicleType: _vehicleType,\n            walletAddress: msg.sender,\n            pendingFines: 0,\n            rewardBalance: 0,\n            points: 100 // Start with 100 points\n        });\n        allUsers.push(msg.sender); // Add this line after creating new user\n        vehicleToUser[_vehicleRegistrationNumber] = msg.sender;\n        totalpoints += 100;\n        emit UserCreated(msg.sender, _basename, _vehicleRegistrationNumber);\n    }\n\n    // Report a violation\n    function reportViolation(\n        address _user,\n        string memory _violationType,\n        uint256 _timestamp,\n        string memory _area\n    ) public {\n        require(users[_user].walletAddress != address(0), \"User does not exist\");\n        require(violationFines[_violationType] > 0, \"Invalid violation type\");\n        require(_timestamp <= block.timestamp, \"Invalid timestamp\");\n\n        uint256 fineAmount = violationFines[_violationType];\n        userViolations[_user].push(\n            Violation({\n                time: _timestamp,\n                violationType: _violationType,\n                area: _area,\n                reportedBy: msg.sender,\n                isPaid: false,\n                fineAmount: fineAmount\n            })\n        );\n        users[_user].pendingFines++;\n        emit ViolationReported(_user, _violationType, msg.sender, fineAmount);\n    }\n\n    // Fetch all violations of a user\n    function getUserViolations(address _user) public view returns (Violation[] memory) {\n        return userViolations[_user];\n    }\n\n    // Pay a fine\n    function payFine(\n        address _user,\n        uint256 _violationIndex,\n        uint256 nullifierSeed,\n        uint256 nullifier,\n        uint256 timestamp,\n        uint256[4] memory revealArray,\n        uint256[8] memory groth16Proof\n    ) public payable {\n        require(users[_user].walletAddress != address(0), \"User does not exist\");\n        require(!userViolations[_user][_violationIndex].isPaid, \"Fine already paid\");\n        bool isValid = IAnonAadhaar(anonAadhaarVerifierAddr).verifyAnonAadhaarProof(\n            nullifierSeed,\n            nullifier,\n            timestamp,\n            addressToUint256(msg.sender),\n            revealArray,\n            groth16Proof\n        );\n        require(isValid, \"[AnonAadhaarVote]: proof sent is not valid.\");\n\n        Violation storage violation = userViolations[_user][_violationIndex];\n        require(msg.value == violation.fineAmount, \"Payment must be equal to the fine amount\");\n\n        violation.isPaid = true;\n        users[_user].pendingFines--;\n        finesPaid[_user] += msg.value;\n        totalRewardPool += msg.value; // Add fine amount to total reward pool\n        emit FinePaid(_user, _violationIndex, msg.value);\n    }\n\n    function addPoints(string memory _basename, uint256 _points) public {\n        address userAddress;\n        for (uint i = 0; i < allUsers.length; i++) {\n            if (keccak256(bytes(users[allUsers[i]].basename)) == keccak256(bytes(_basename))) {\n                userAddress = allUsers[i];\n                break;\n            }\n        }\n        require(userAddress != address(0), \"User not found\");\n        \n        users[userAddress].points += _points;\n        totalpoints += _points;\n    }\n\n    function convertPointsToRewards() public {\n        User storage user = users[msg.sender];\n        require(user.points > 0, \"No points to convert\");\n        require(totalRewardPool > 0, \"Reward pool is empty\");\n        require(totalpoints > 0, \"No points in the system\");\n\n        // Calculate user's share of the reward pool\n        uint256 rewardShare = (user.points * totalRewardPool) / totalpoints;\n\n        // Ensure contract has enough Ether\n        require(address(this).balance >= rewardShare, \"Not enough funds in contract to pay rewards\");\n\n        // Transfer reward to the user's wallet\n        (bool success, ) = msg.sender.call{ value: rewardShare }(\"\");\n        require(success, \"Reward transfer failed\");\n\n        // Update user's internal balances\n        user.rewardBalance += rewardShare; // For internal tracking\n        totalpoints-=user.points;\n        user.points = 0; // Reset points after conversion\n        totalRewardPool -= rewardShare;\n\n        emit RewardUpdated(msg.sender, user.rewardBalance);\n    }\n\n    function getContractBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function getUserDetailsByAddress(\n        address _walletAddress\n    ) public view returns (\n        string memory basename,\n        string memory vehicleNumber,\n        string memory vehicleType,\n        uint256 pendingFines,\n        uint256 rewardBalance,\n        uint256 points\n    ) {\n        require(users[_walletAddress].walletAddress != address(0), \"User does not exist\");\n        User memory user = users[_walletAddress];\n        return (\n            user.basename,\n            user.vehicleRegistrationNumber,\n            user.vehicleType,\n            user.pendingFines,\n            user.rewardBalance,\n            user.points\n        );\n    }\n\n    function getUserDetailsByBasename(\n        string memory _basename\n    ) public view returns (\n        string memory basename,\n        string memory vehicleNumber,\n        string memory vehicleType,\n        address walletAddress,\n        uint256 pendingFines,\n        uint256 rewardBalance,\n        uint256 points\n    ) {\n        address userAddress;\n        for (uint i = 0; i < allUsers.length; i++) {\n            if (keccak256(bytes(users[allUsers[i]].basename)) == keccak256(bytes(_basename))) {\n                userAddress = allUsers[i];\n                break;\n            }\n        }\n        require(userAddress != address(0), \"User not found\");\n        \n        User memory user = users[userAddress];\n        return (\n            user.basename,\n            user.vehicleRegistrationNumber,\n            user.vehicleType,\n            user.walletAddress,\n            user.pendingFines,\n            user.rewardBalance,\n            user.points\n        );\n    }\n\n    function getAllUsersAndPoints()\n        public\n        view\n        returns (\n            string[] memory basenames, // changed from usernames to basenames\n            uint256[] memory points\n        )\n    {\n        uint256 totalUsers = allUsers.length;\n        basenames = new string[](totalUsers); // changed variable name\n        points = new uint256[](totalUsers);\n\n        for (uint256 i = 0; i < totalUsers; i++) {\n            address userAddress = allUsers[i];\n            basenames[i] = users[userAddress].basename; // changed variable name\n            points[i] = users[userAddress].points;\n        }\n\n        return (basenames, points); // changed return variable name\n    }\n\n    function getUserPoints(address _userAddress) public view returns (uint256) {\n        require(users[_userAddress].walletAddress != address(0), \"User does not exist\");\n        return users[_userAddress].points;\n    }\n\n    struct UserViolationInfo {\n        address userAddress;\n        string basename;\n        Violation[] violations;\n    }\n\n    function getAllUsersAndViolations() public view returns (UserViolationInfo[] memory) {\n        uint256 totalUsers = allUsers.length;\n        UserViolationInfo[] memory allUserInfo = new UserViolationInfo[](totalUsers);\n\n        for (uint256 i = 0; i < totalUsers; i++) {\n            address userAddr = allUsers[i];\n            allUserInfo[i] = UserViolationInfo({\n                userAddress: userAddr,\n                basename: users[userAddr].basename,\n                violations: userViolations[userAddr]\n            });\n        }\n\n        return allUserInfo;\n    }\n\n    // Add this new function for daily points update\n    function addDailyPoints() public {\n        uint256 totalUsers = allUsers.length;\n        for (uint256 i = 0; i < totalUsers; i++) {\n            address userAddr = allUsers[i];\n            if (users[userAddr].pendingFines == 0) {\n                users[userAddr].points += 10;\n            }\n        }\n    }\n}\n"
    },
    "interfaces/IAnonDigiLocker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.19;\n\ninterface IAnonDigiLocker {\n    function verifyAnonDigiLockerProof(\n        uint nullifierSeed,\n        uint nullifier,\n        uint documentType,\n        uint reveal,\n        uint signal,\n        uint[8] memory groth16Proof\n    ) external view returns (bool);\n}"
    },
    "interfaces/IAnonDigiLockerGroth16Verifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.19;\n\ninterface IAnonDigiLockerGroth16Verifier {\n    function verifyProof(\n        uint[2] calldata _pA,\n        uint[2][2] calldata _pB,\n        uint[2] calldata _pC,\n        uint[6] calldata publicInputs\n    ) external view returns (bool);\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}