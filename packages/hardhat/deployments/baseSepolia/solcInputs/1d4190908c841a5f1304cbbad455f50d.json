{
  "language": "Solidity",
  "sources": {
    "@anon-aadhaar/contracts/interfaces/IAnonAadhaar.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.19;\n\ninterface IAnonAadhaar {\n    function verifyAnonAadhaarProof(\n        uint nullifierSeed,\n        uint nullifier,\n        uint timestamp,\n        uint signal,\n        uint[4] memory revealArray,\n        uint[8] memory groth16Proof\n    ) external view returns (bool);\n}\n"
    },
    "@anon-aadhaar/contracts/interfaces/IAnonAadhaarVote.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.19;\n\ninterface IAnonAadhaarVote {\n\n    struct Proposal {\n        string description;\n        uint256 voteCount;\n    }\n\n    event Voted(address indexed _from, uint256 indexed _propositionIndex);\n}"
    },
    "contracts/Backend.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport '@anon-aadhaar/contracts/interfaces/IAnonAadhaar.sol';\r\nimport '@anon-aadhaar/contracts/interfaces/IAnonAadhaarVote.sol';\r\nimport \"../interfaces/IAnonDigiLockerGroth16Verifier.sol\";\r\nimport \"../interfaces/IAnonDigiLocker.sol\";\r\n\r\ncontract Backend {\r\n    address public anonAadhaarVerifierAddr;\r\n    address public verifier;\r\n    uint256 public immutable storedPublicKeyHash;\r\n    struct User {\r\n        string name;\r\n        string vehicleRegistrationNumber;\r\n        address walletAddress;\r\n        uint256 pendingFines;\r\n    }\r\n\r\n    struct Violation {\r\n        uint256 time;\r\n        string violationType;\r\n        string area;           // Add area field\r\n        address reportedBy;\r\n        bool isPaid;\r\n        uint256 fineAmount;\r\n    }\r\n\r\n    struct CreateUserParams {\r\n        uint256 nullifierSeed1;\r\n        uint256 nullifier1;\r\n        uint256 timestamp;\r\n        uint256[4] revealArray;\r\n        uint256[8] groth16Proof1;\r\n        uint256 nullifier2;\r\n        uint256 nullifierSeed2;\r\n        uint256 documentType;\r\n        uint256 reveal;\r\n        uint256 signal;\r\n        uint256[8] groth16Proof2;\r\n    }\r\n\r\n    mapping(address => User) public users;\r\n    mapping(string => address) public vehicleToUser;\r\n    mapping(address => Violation[]) userViolations;\r\n    mapping(address => uint256) public finesPaid;\r\n    mapping(string => uint256) public violationFines;\r\n\r\n    event UserCreated(address indexed userAddress, string name, string vehicleRegistrationNumber);\r\n    event ViolationReported(address indexed user, string violationType, address reportedBy, uint256 fineAmount);\r\n    event FinePaid(address indexed user, uint256 violationIndex, uint256 amount);\r\n\r\n    constructor(address _verifierAddr, address _verifier, uint256 _pubkeyHash) {\r\n        verifier=_verifier;\r\n        // Initialize some dummy fine amounts for violation types\r\n        anonAadhaarVerifierAddr = _verifierAddr;\r\n        storedPublicKeyHash = _pubkeyHash;\r\n        violationFines[\"Speeding\"] = 200;\r\n        violationFines[\"Parking\"] = 50;\r\n        violationFines[\"Red Light\"] = 50;\r\n        violationFines[\"Wrong way\"] = 50;\r\n    }\r\n\r\n    function addressToUint256(address _addr) private pure returns (uint256) {\r\n        return uint256(uint160(_addr));\r\n    }\r\n\r\n    function _hash(uint256 message) private pure returns (uint256) {\r\n        return uint256(keccak256(abi.encodePacked(message))) >> 3;\r\n    }\r\n\r\n    function verifyAnonAadhaar(\r\n        uint256 nullifierSeed,\r\n        uint256 nullifier,\r\n        uint256 timestamp,\r\n        uint256[4] memory revealArray,\r\n        uint256[8] memory groth16Proof\r\n    ) internal returns (bool) {\r\n        return IAnonAadhaar(anonAadhaarVerifierAddr).verifyAnonAadhaarProof(\r\n            nullifierSeed,\r\n            nullifier,\r\n            timestamp,\r\n            addressToUint256(msg.sender),\r\n            revealArray,\r\n            groth16Proof\r\n        );\r\n    }\r\n\r\n    function verifyDigiLocker(\r\n        uint256[8] memory proof,\r\n        uint256 nullifier,\r\n        uint256 documentType,\r\n        uint256 reveal,\r\n        uint256 nullifierSeed,\r\n        uint256 signal\r\n    ) internal view returns (bool) {\r\n        uint256 signalHash = _hash(signal);\r\n        return IAnonDigiLockerGroth16Verifier(verifier).verifyProof(\r\n            [proof[0], proof[1]],\r\n            [[proof[2], proof[3]], [proof[4], proof[5]]],\r\n            [proof[6], proof[7]],\r\n            [storedPublicKeyHash, nullifier, documentType, reveal, nullifierSeed, signalHash]\r\n        );\r\n    }\r\n    \r\n    // Create a new user\r\n    function createUser(\r\n        string memory _name,\r\n        string memory _vehicleRegistrationNumber,\r\n        CreateUserParams memory params\r\n    ) public payable {\r\n        require(users[msg.sender].walletAddress == address(0), \"User already exists\");\r\n        \r\n        bool isValid = verifyAnonAadhaar(\r\n            params.nullifierSeed1,\r\n            params.nullifier1,\r\n            params.timestamp,\r\n            params.revealArray,\r\n            params.groth16Proof1\r\n        );\r\n        require(isValid, '[AnonAadhaarVote]: proof sent is not valid.');\r\n\r\n        bool isValid2 = verifyDigiLocker(\r\n            params.groth16Proof2,\r\n            params.nullifier2,\r\n            params.documentType,\r\n            params.reveal,\r\n            params.nullifierSeed2,\r\n            params.signal\r\n        );\r\n        require(isValid2, '[AnonAadhaarVote]: DL Proof sent is not valid.');\r\n\r\n        users[msg.sender] = User({\r\n            name: _name,\r\n            vehicleRegistrationNumber: _vehicleRegistrationNumber,\r\n            walletAddress: msg.sender,\r\n            pendingFines: 0\r\n        });\r\n        vehicleToUser[_vehicleRegistrationNumber] = msg.sender;\r\n        emit UserCreated(msg.sender, _name, _vehicleRegistrationNumber);\r\n    }\r\n\r\n    // Report a violation\r\n    function reportViolation(\r\n        address _user, \r\n        string memory _violationType,\r\n        uint256 _timestamp,\r\n        string memory _area\r\n    ) public {\r\n        require(users[_user].walletAddress != address(0), \"User does not exist\");\r\n        require(violationFines[_violationType] > 0, \"Invalid violation type\");\r\n        require(_timestamp <= block.timestamp, \"Invalid timestamp\");\r\n\r\n        uint256 fineAmount = violationFines[_violationType];\r\n        userViolations[_user].push(Violation({\r\n            time: _timestamp,\r\n            violationType: _violationType,\r\n            area: _area,\r\n            reportedBy: msg.sender,\r\n            isPaid: false,\r\n            fineAmount: fineAmount\r\n        }));\r\n        users[_user].pendingFines++;\r\n        emit ViolationReported(_user, _violationType, msg.sender, fineAmount);\r\n    }\r\n\r\n    // Fetch all violations of a user\r\n    function getUserViolations(address _user) public view returns (Violation[] memory) {\r\n        return userViolations[_user];\r\n    }\r\n\r\n    // Pay a fine\r\n    function payFine(address _user, uint256 _violationIndex, uint256 nullifierSeed,\r\n    uint256 nullifier,\r\n    uint256 timestamp,\r\n    uint256[4] memory revealArray,\r\n    uint256[8] memory groth16Proof) public payable {\r\n        require(users[_user].walletAddress != address(0), \"User does not exist\");\r\n        require(!userViolations[_user][_violationIndex].isPaid, \"Fine already paid\");\r\n        bool isValid = IAnonAadhaar(anonAadhaarVerifierAddr).verifyAnonAadhaarProof(\r\n            nullifierSeed,\r\n            nullifier,\r\n            timestamp,\r\n            addressToUint256(msg.sender),\r\n            revealArray,\r\n            groth16Proof\r\n        );\r\n        require(isValid, '[AnonAadhaarVote]: proof sent is not valid.');\r\n\r\n        Violation storage violation = userViolations[_user][_violationIndex];\r\n        require(msg.value == violation.fineAmount, \"Payment must be equal to the fine amount\");\r\n\r\n        violation.isPaid = true;\r\n        users[_user].pendingFines--;\r\n        finesPaid[_user] += msg.value;\r\n        emit FinePaid(_user, _violationIndex, msg.value);\r\n    }\r\n}\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\n// pragma solidity ^0.8.19;\r\n\r\n// import '@anon-aadhaar/contracts/interfaces/IAnonAadhaar.sol';\r\n// import '@anon-aadhaar/contracts/interfaces/IAnonAadhaarVote.sol';\r\n\r\n// contract AnonAadhaarVote is IAnonAadhaarVote {\r\n//     string public votingQuestion;\r\n//     address public anonAadhaarVerifierAddr;\r\n\r\n//     // List of proposals\r\n//     Proposal[] public proposals;\r\n\r\n//     // Mapping to track if a userNullifier has already voted\r\n//     mapping(uint256 => bool) public hasVoted;\r\n\r\n//     // Constructor to initialize proposals\r\n//     constructor(\r\n\r\n//         address _verifierAddr\r\n//     ) {\r\n//         anonAadhaarVerifierAddr = _verifierAddr;\r\n//         votingQuestion = _votingQuestion;\r\n//         for (uint256 i = 0; i < proposalDescriptions.length; i++) {\r\n//             proposals.push(Proposal(proposalDescriptions[i], 0));\r\n//         }\r\n//     }\r\n\r\n//     /// @dev Convert an address to uint256, used to check against signal.\r\n//     /// @param _addr: msg.sender address.\r\n//     /// @return Address msg.sender's address in uint256\r\n//     function addressToUint256(address _addr) private pure returns (uint256) {\r\n//         return uint256(uint160(_addr));\r\n//     }\r\n\r\n//     /// @dev Check if the timestamp is more recent than (current time - 3 hours)\r\n//     /// @param timestamp: msg.sender address.\r\n//     /// @return bool\r\n//     function isLessThan3HoursAgo(uint timestamp) public view returns (bool) {\r\n//         return timestamp > (block.timestamp - 3 * 60 * 60);\r\n//     }\r\n\r\n//     /// @dev Register a vote in the contract.\r\n//     /// @param proposalIndex: Index of the proposal you want to vote for.\r\n//     /// @param nullifierSeed: Nullifier Seed used while generating the proof.\r\n//     /// @param nullifier: Nullifier for the user's Aadhaar data.\r\n//     /// @param timestamp: Timestamp of when the QR code was signed.\r\n//     /// @param revealArray: Array of the values used as input for the proof generation (equal to [0, 0, 0, 0] if no field reveal were asked).\r\n//     /// @param groth16Proof: SNARK Groth16 proof.\r\n//     function voteForProposal(\r\n//     uint256 proposalIndex,\r\n//     uint256 nullifierSeed,\r\n//     uint256 nullifier,\r\n//     uint256 timestamp,\r\n//     uint256[4] memory revealArray,\r\n//     uint256[8] memory groth16Proof\r\n// ) public payable {\r\n//     require(!hasVoted[nullifier], '[AnonAadhaarVote]: User has already voted');\r\n//     require(proposalIndex < proposals.length, '[AnonAadhaarVote]: Invalid proposal index');\r\n\r\n//     bool isValid = IAnonAadhaar(anonAadhaarVerifierAddr).verifyAnonAadhaarProof(\r\n//         nullifierSeed,\r\n//         nullifier,\r\n//         timestamp,\r\n//         addressToUint256(msg.sender),\r\n//         revealArray,\r\n//         groth16Proof\r\n//     );\r\n//     require(isValid, '[AnonAadhaarVote]: proof sent is not valid.');\r\n\r\n//     hasVoted[nullifier] = true;\r\n//     proposals[proposalIndex].voteCount++;\r\n\r\n//     emit Voted(msg.sender, proposalIndex);\r\n// }\r\n\r\n\r\n//     // Function to get the total number of proposals\r\n//     function getProposalCount() public view returns (uint256) {\r\n//         return proposals.length;\r\n//     }\r\n\r\n//     // Function to get proposal information by index\r\n//     function getProposal(\r\n//         uint256 proposalIndex\r\n//     ) public view returns (string memory, uint256) {\r\n//         require(\r\n//             proposalIndex < proposals.length,\r\n//             '[AnonAadhaarVote]: Invalid proposal index here'\r\n//         );\r\n\r\n//         Proposal memory proposal = proposals[proposalIndex];\r\n//         return (proposal.description, proposal.voteCount);\r\n//     }\r\n\r\n//     // Function to get the total number of votes across all proposals\r\n//     function getTotalVotes() public view returns (uint256) {\r\n//         uint256 totalVotes = 0;\r\n//         for (uint256 i = 0; i < proposals.length; i++) {\r\n//             totalVotes += proposals[i].voteCount;\r\n//         }\r\n//         return totalVotes;\r\n//     }\r\n\r\n//     // Function to check if a user has already voted\r\n//     function checkVoted(uint256 _nullifier) public view returns (bool) {\r\n//         return hasVoted[_nullifier];\r\n//     }\r\n// }"
    },
    "interfaces/IAnonDigiLocker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.19;\r\n\r\ninterface IAnonDigiLocker {\r\n    function verifyAnonDigiLockerProof(\r\n        uint nullifierSeed,\r\n        uint nullifier,\r\n        uint documentType,\r\n        uint reveal,\r\n        uint signal,\r\n        uint[8] memory groth16Proof\r\n    ) external view returns (bool);\r\n}"
    },
    "interfaces/IAnonDigiLockerGroth16Verifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.19;\r\n\r\ninterface IAnonDigiLockerGroth16Verifier {\r\n    function verifyProof(\r\n        uint[2] calldata _pA,\r\n        uint[2][2] calldata _pB,\r\n        uint[2] calldata _pC,\r\n        uint[6] calldata publicInputs\r\n    ) external view returns (bool);\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}